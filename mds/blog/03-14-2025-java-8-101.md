# J8FN (Java 8 For Noobs)

I'm writing this blog post to finalize the knowledge gained from my last uni course that will be used during my Amazon internship.

I don't have enterprise knowledge, so this is based on textbooks and slides from the course.

Table of contents:

- Introduction
- Type system
- Subtype rules & Polymorphism
- Primitive Types
- Wrapper types
- Autoboxing & Unboxing
- Exceptions
- Equality check
- Internal, Local, Anonymous Classes & Lambda expressions
- Internal
- Local
- Anonymous
- Lambda
- Generics
- Extends & Super
- Wildcards
- Jolly
- Limits
- Design by Contract
- Precondition vs Postcondition
- Completeness vs Correctness
- Iterable & Iterator
- Comparable & Comparator
- Ordering properties

## Introduction

Java is based on the JVM (Java Virtual Machine), which makes it portable across multiple architectures (and was historically considered slow because of it).

If you want to dive deeper (or maybe wait for a future post of mine), you can read about the JVM and other intrinsic mechanism on the internet.

Before starting, you need basic OOP knowledge...Why? Because from now on everything will be an object. We will turn into objects as well, so not be scared.

In Java everything is a class, and a class is basically a blueprints for creating objects. When a class is instantiated using the new keyword, an object is created in the heap memory, which is the dynamic memory area where objects live until they are garbage collected.
Simultaneously a reference to this object is stored in the stack memory, which is a smaller and faster memory area that handles method calls and local variables.
For example when ```Car myCar = new Car()``` is executed, the myCar reference is stored in the stack, while the actual Car object is created in the heap.

## Type system

Java is a statically typed language aka *every expression type must be known at compile time and for each expression the type represent all the possible values that can be attributed to*.

A type can be:

- **declared** (static): the type attributed to the expression during the declaration.
- **effective** (dynamic): the type attributed to the expression during the runtime, while doing polymorphism and other runtime specific type mechanism.

### Subtype rules & Polymorphism

I mentioned **Polymorphism** before, what's that? It's a way to implement [Inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#:~:text=In%20object%2Doriented%20programming%2C%20inheritance,inheritance%2C%20retaining%20similar%20implementation.).

Thanks to the subtype rules, we know when the polymorphism happens, without giving errors.

Considering T and U as types:

0) T *is a subtype of* himself
2) T *is a subtype of* Object
1) T *is a subtype of* U if T implements or extends U
3) null *is a subtype of* T
4) if T *is a subtype of* U => T[] *is a subtype of* U[]

These also shapes:

- the ```Ã¬nstanceof``` behavior: ```(object of type T) istanceof U``` gives false if it's null or if T is not a subtype of U.
- the **Assignable** relation: a type T is assignable to a type U if T is a subtype of U or if T and U are primitive types.

### Primitive Types

I actually lied to you, not everything is a object.

Primitive types are not objects. You can cast primitive types by doing implicit or explicit casts:

- **Implicit** casting is done only if this graph below is followed:

![java-types-graph](../../java/java-cast-types.png)

- **Explicit** cast is done manually, but you could actually lose valuable informations (f.e. casting from ```double``` to ```int```)

### Wrapper types

These are objects, and as the name suggest, they *Wrap* values, by offering methods and every benefit of objects to basic types.

They are **immutable** and **final**, so you can't modify it's reference after the declaration.

#### Autoboxing and Unboxing

Mechanism introduced in Java 8 that automatically convert during runtime a basic type into a Wrapper during a declaration using the static method ```valueOf``` implicitly:

```java
Integer n = 7 // Integer n = Integer.valueOf(7)
```

## Exceptions

There are two types of exceptions:

- **Checked**: these are caused by external factors (f.e. ```FileNotFoundException```), needs to be handled with a try...catch() or by declaring the throws on the method, so the compiler don't complain.
- **Unchecked**: these are caused by the programmer, the compiler don't complain if you don't handle them beforehand but causes runtime errors.

```RuntimeException``` and exceptions that extends ```Error``` are unchecked, while all the others from the standard library are checked.

![java-exceptions-tree](../../java/java-tree-exceptions.png)


## Equality check

So there is a twist here: ```==``` it's different from other languages.

If you use ```==``` while comparing primitive types, it works as intended, but if it's being used with Objects, it will actually compare the references in the Heap and not the *real* equality.

So, how do you perform an equality check for objects? By using the ```equals()``` method.

This method must respect the **equality relation properties**:

- *Reflexive*: x.equals(x) is true
- *Symmetric*: x.equals(y) is true <=> y.equals(x) is true
- *Transitive*: x.equals(y) is true && y.equals(z) is true => x.equals(z) is true

And there are three types of **Equality criterions**:

- *Uniform*: all the subclasses inherit the equals() method of the superclass.
- *Non-uniform*: the subclasses overrides the equals() method to give it custom behaviour.
- *Mixed*: a mix of the above.

This is an example of how to re-define the equals() method for non-uniform criterion, considering Manager that extends Employee:

```java
// Employee
public boolean equals(Object o) {
    if (o == null) return false;
    if (o.getClass() != this.getClass()) return false;
    Employee e = (Employee) o;

    // ...
}

// Manager
public boolean equals(Object o) {
    if (!super.equals(o)) return false;
    Manager m = (Manager) o;

    // ...
}
```

## Internal, Local, Anonymous Classes & Lambda expressions

### Internal

These are classes defined inside other classes, to organize better the inheritance structure.

```java
public class A {
    private class B {
        // ...
    }

    class C {
        // ...
    }
}
```

Here B is only visible in A and C is visible to all the classes inside the same package of A.

These classes can be accessed via ```A.B``` or ```A.C``` syntax.

### Local

These are classes defined locally, inside a method, that after the scope are destroyed.

```java
class MyActionListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {
        label.setText("Vibe coding is slop")
    }
}

b.addActionListener(new MyActionListener());
```

### Anonymous

These are basically local classes, but without a name, that's why they are called anonymous.

They are used to instantiate an object that will be used inside other existing classes or interfaces, and that will die after its declaration.

For example, following the example of a local class, we can rewrite the thing like this:

```java
b.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        label.setText("Vibe coding is slop")
    }
})
```

### Lambda

Lambdas are a way to define anonymous classes in a more compact way by using the [lambda calculus](https://plato.stanford.edu/entries/lambda-calculus/) design.

You can use lambda when implementing **Functional Interfaces** (interfaces with only 1 abstract method).

Let's write the example above but with lambdas:

```java
b.addActionListener(() -> {
    label.setText("Vibe coding is slop")
})
```

Neat, right? This is not an exhaustive example on what you can do with them, so dig deeper by yourself. Here is a [video](https://www.youtube.com/watch?v=lIXs4Y8sJCk&list=PLL8woMHwr36HQhhPPdV_T8rigbuywMpD7) to help you start.

## Generics

Always from the same guy, there is this [video](https://www.youtube.com/watch?v=CKWw7J5MsyY) that explains the concept in a good and coincise way but I'll also explain it here in the best and simplest way I can.

Generics are a way to implement 'dynamic' polymorphism. They are present in almost every modern language and are used to write modular code. The type checking runs during compile time, so they also guarantee type-safety.

Thanks to this feature, it's possible to write classes or methods that changes their behavior based on the type provided.

The basic syntax is:

```java
// Class
class Example<T> {
    T element;
    // ...
}

class Example<T, U> {
    // Here the elements types could be different
    T element1;
    U element2;
    // ...
}

// Method
<T> T exampleMethod(T el1, T el2) {} // return and inputs type T

<T, S> T exampleMethod(T el1, S el2) {} // return type T and inputs type T and S
```

But this is limited to the actual type, without much flexibility. To give the class or method more flexibility we will use: extends, super and wildcards.

### Upper bound

This is used to give the power of inheritance to generics.

Let's suppose we have a method that accept Employee and all of his subclasses

```java
public void giveSalary(ArrayList<Employee> listOfEmployees) { /*...*/ }
```

Would this work? NO, because generics are **Invariants** and that means that polymorphism wont work, if something it's of type T, then only type T could be assigned.

It comes to our help the upper bound, ```<T extends U>``` , this tell the compiler that T can be U or a subtype of U.

So to make the example before work, we can use it by doing:

```java
public <T extends Employee> void giveSalary(ArrayList<T> listOfEmployees) { /*...*/ }
```

By using this you'll gain more flexibility but it's still somewhat restricted and we want more! (however keep in mind that sometimes the more, the worst.)

### Wildcards

Wildcards gives a lot of flexibility but also imposes some costraints since they can't be known at compile-time.

There are three types: Jolly (or Unbounded), Upper bounded and Lower bounded.

![wildcards-graph](../../java/wildcards-graph.png)

#### Jolly

```?``` aka some unknown generic type aka the supertype common to everything.

Let's say we have ```List<?>``` , we can assign to it every possible List: ```List<Employee>, List<Manager>, List<String>...```

But it's not that good to use only jolly types because they imposes two conditions when calling methods:

- If a method of a ```A<T>``` accept an argument of type T and we use a reference of type ```A<?>``` then only null can be passed to it since the compiler can't infere the actual type.
- If a method of a ```A<T>``` return a value of type T and we use this method on a reference of type ```A<?>``` then we can assign the returned value only to ```Object```.

A bit confusing, so let's clarify this with an example regarding ```LinkedList<T>``` :

```java
// Let's suppose we pass a LinkedList<Integer> to this
public static void moveHeadToTail(LinkedList<?> l) {
    Object head = l.removeFirst(); // accepted
    Integer head = l.removeFirst(); // compilation error

    l.addLast(3) // compilation error
    l.addLast(null) // accepted
}
```

I hope everything now is more clear.

#### Upper bounded

```<? extends T>``` aka an unknown type (the common supertype of everything) that extends T

#### Lower bounded

```<? super T>``` aka an unknown type that is supertype of T

Similar to the Jolly type, there are constraints for these two types when calling methods. Below is a table that summarizes the three types:

![wildcards-table](../../java/wildcards-table.png)

### Erasure



## Design by Contract

This is not really a Java related thing, but it could be useful to write more organized and maintainable code.

I'll only talk about method contracts but this could also be applied to classes/interfaces and so on...

A good method must be **complete** (respect the *precondition*) and **correct** (respect the *postcondition*)

If a method is being overriden by subclasses, the parent contract must be respected.

### Precondition vs Postcondition

The **precondition** is referring to input parameters, that are used to accomplish the method task correctly aka **postcondition**

### Completeness vs Correctness

**Completeness** is when a method accept all possible valid inputs, while **Correctness** is when a method never accept invalid inputs.

You can't always define a method that it's both complete and correct, so you must decide if you want the method to be more robust (correct) or if you want it to be more flexible (complete).

## Iterable and Iterator

![java-iterable-iterator](../../java/java-iterable-iterator.png)

```Iterable``` is an interface that is implemented by a structure that is designed to be *iterated through*.

```Iterator``` is the interface that when implemented act as an index inside the structure, with custom methods that must be implemented: ```hasNext(), next()``` and more. If you want more details go read the [docs](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html).

```java
// Iterable
public class CustomIterable implements Iterable<...> {
    public CustomIterable(...) {
        // ...
    }

    // Iterator (this also can be defined in his own class file)
    @Override
    public Iterator<...> iterator() {
        // ...
    }

    private class CustomIterator implements Iterator<...> {
        private int currentIndex = 0;

        @Override
        public boolean hasNext() {
            // return true if there are other elements in the structure
        }

        @Override
        public String next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }

            // return the next element
        }
    }

```

Note: If you want to use enhanced for loop (```for(T el : structure) {}```), the structure that will be iterated needs to implement ```Iterable```.

## Comparable and Comparator

```Comparable``` is used when the structure is ordered following the natural ordering and it's usually defined for types like Numbers, Strings etc...

```Comparator``` is used when the structure has multiple ways of being ordered (based on the custom comparator that we will implement) or if we don't want to modify the natural ordering implementation.

```java
// Comparable
public class Employee implements Comparable<Employee> {
    private int salary;
    private String name;

    @Override
    public int compareTo(Employee x) {
        return name.compareTo(x.name) // Here we are using the natural ordering offered by String type (lexicographically)
    }
}

//Comparator
public class Employee {
    private int salary;
    private String name;

    // Here compareTo it's used but you could've written something that adhere to ordering properties and rules
    public static final Comparator<Employee> comparatorByName = new Comparator<>() {
        public int compare(Employee a, Employee b) {
            return a.name.compareTo(b.name);
        }
    };

    public static final Comparator<Employee> comparatorBySalary = new Comparator<>() {
        public int compare(Employee a, Employee b) {
            return a.salary.compareTo(b.salary);
        }
    };
}
```

![java-comparable-comparator](https://miro.medium.com/v2/resize:fit:1200/1*zeTUgb3jpIfN4nuw36BCEw.png)

This tables give a quick and useful overview, and as we can see, one uses ```compareTo()``` and the other one ```compare()```.

If you want to dive deeper, as before, go read the [docs](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html).

### Ordering properties and rules

Considering a custom Comparator, a b c as elements and sgn() function that gives the sign of the result, then c.compare() must adhere to these properties:
- **Reflexive and Antisymmetric**: sgn(c.compare(a,b)) == -sgn(c.compare(b,a))
- **Transitive**: c.compare(a,b) < 0 and c.compare(b,c) < 0 => c.compare(a,c) < 0
- **Extra**: if sgn(c.compare(a,b)) == 0 => sgn(c.compare(a,c)) == sgn(c.compare(b,c))

And the rules are that:
- if a < b then a negative number is returned
- if a == b then 0 is returned
- if a > b then a positive number is returned
